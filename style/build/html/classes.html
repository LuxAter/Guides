

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Classes &mdash; Google C++ Style Guide 1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="Google C++ Style Guide 1.0 documentation" href="index.html"/>
        <link rel="next" title="Functions" href="functions.html"/>
        <link rel="prev" title="Scoping" href="scoping.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Google C++ Style Guide
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="header_files.html">Header Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="scoping.html">Scoping</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Classes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#doing-work-in-constructors">Doing work in Constructors</a></li>
<li class="toctree-l2"><a class="reference internal" href="#implicit-conversions">Implicit Conversions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#copyable-and-movable-types">Copyable and Movable Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#structs-vs-classes">Structs vs. Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#inheritance">Inheritance</a></li>
<li class="toctree-l2"><a class="reference internal" href="#multiple-inheritance">Multiple Inheritance</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interfaces">Interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="#operator-overloading">Operator Overloading</a></li>
<li class="toctree-l2"><a class="reference internal" href="#access-control">Access Control</a></li>
<li class="toctree-l2"><a class="reference internal" href="#declaration-order">Declaration Order</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="other_cpp_features.html">Other C++ Features</a></li>
<li class="toctree-l1"><a class="reference internal" href="naming.html">Naming</a></li>
<li class="toctree-l1"><a class="reference internal" href="comments.html">Comments</a></li>
<li class="toctree-l1"><a class="reference internal" href="formatting.html">Formatting</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Google C++ Style Guide</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Classes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="classes">
<h1>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h1>
<p>Classes are the fundamental unit of code in C++. Naturally, we use them extensively. This section lists the main dos and don’ts you should follow when writing a class.</p>
<div class="section" id="doing-work-in-constructors">
<h2>Doing work in Constructors<a class="headerlink" href="#doing-work-in-constructors" title="Permalink to this headline">¶</a></h2>
<p>Avoid virtual method calls in constructors, and avoid initialization that can fail if you can’t signal an error.</p>
<dl class="docutils">
<dt>Definition:</dt>
<dd>It is possible to preform arbitrary initialization in the body of the constructor.</dd>
<dt>Pros:</dt>
<dd><ul class="first last simple">
<li>No need to worry about whether the class has been initialized or not.</li>
<li>Objects that are fully initialized by constructor call can be <code class="docutils literal"><span class="pre">const</span></code> and may also be easier to use with standard containers or algorithms.</li>
</ul>
</dd>
<dt>Cons:</dt>
<dd><ul class="first last simple">
<li>I the work calls virtual functions, these calls will not get dispatched to the subclass implementations. Future modification to you class can quietly introduce this problem even if your class is not currently subclassed, causing much confusion.</li>
<li>There is no easy way for constructors to signal errors, short of crashing the program (not always appropriate) or using exceptions (which are ‘forbidden’_).</li>
<li>If the work failed, we now have an object whose initialization cod failed, so it may be unusual state requiring a <code class="docutils literal"><span class="pre">bool</span> <span class="pre">IsBalid()</span></code> state checking mechanism (or similar) which is easy to forget to call.</li>
<li>You cannot take the address of a constructor, so whatever work is done in the constructor cannot easily be handed off to, for examples, another thread.</li>
</ul>
</dd>
<dt>Decision:</dt>
<dd>Constructors should never call virtual functions. If appropriate for your code, terminating the program may be an appropriate error handling response. Otherwise, consider a factory function or <code class="docutils literal"><span class="pre">Init()</span></code> method. Avoid <code class="docutils literal"><span class="pre">Init()</span></code> methods on objects with no other states that affect which public methods may be called (semi-constructed objects of this form are particularly hard to work with correctly).</dd>
</dl>
</div>
<div class="section" id="implicit-conversions">
<h2>Implicit Conversions<a class="headerlink" href="#implicit-conversions" title="Permalink to this headline">¶</a></h2>
<p>Do not define implicit conversions. Use the <code class="docutils literal"><span class="pre">explicit</span></code> keyword for conversion operators and single-argument constructors.</p>
<dl class="docutils">
<dt>Definition:</dt>
<dd><p class="first">Implicit conversions allow an object of one type (called the source type) to be used where a different type (called the destination type) is expected, such as when passing an <code class="docutils literal"><span class="pre">int</span></code> argument to a function that takes a <code class="docutils literal"><span class="pre">double</span></code> parameter.</p>
<p>In addition to the implicit conversions defined by the language, users can define their own, by adding appropriate members to the class definition of the source or destination type. An implicit conversion in the source type is defined by a type conversion operator named after the destination type (e.g. <code class="docutils literal"><span class="pre">operator</span> <span class="pre">bool()</span></code>). An implicit conversion in the destination type is defined by a constructor that can take the source type as its only argument (or only argument with no default value).</p>
<p class="last">The <code class="docutils literal"><span class="pre">explicit</span></code> keyword can be applied to a constructor of (since C++11) a conversion operator, to ensure that it can only be used when the destination type is explicit at the point of use, e.g. with a cast. This applies not only for implicit conversion, but to C++11’s list initialization syntax:</p>
</dd>
</dl>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="k">explicit</span> <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">Func</span><span class="p">(</span><span class="n">Foo</span> <span class="n">f</span><span class="p">);</span>

<span class="n">Func</span><span class="p">({</span><span class="mi">42</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">});</span> <span class="c1">// Error</span>
</pre></div>
</div>
<p>This kind of code isn’t technically an implicit conversion, but the language treats it as one as far as <code class="docutils literal"><span class="pre">explicit</span></code> is concerned.</p>
<dl class="docutils">
<dt>Pros:</dt>
<dd><ul class="first last simple">
<li>Implicit conversions can make a type more usable and expressive by eliminating the need to explicitly name a type when it’s obvious.</li>
<li>Implicit conversion can be a simpler alternative to overloading.</li>
<li>List initialization syntax is a concise and expressive way of initializing objects.</li>
</ul>
</dd>
<dt>Cons:</dt>
<dd><ul class="first last simple">
<li>Implicit conversion can hide type-mismatch bugs, where the destination type does not match the user’s expectation, or the user is unaware that any conversion will take place.</li>
<li>Implicit conversions can make code harder to read, particularly in the presence of overloading, by making it less obvious what code is actually getting called.</li>
<li>Constructors that take a single argument may accidentally be usable as implicit type conversions, even if they are not intended to do so.</li>
<li>When a single-argument constructor is not marked <code class="docutils literal"><span class="pre">explicit</span></code>, there’s no reliable way to tell whether it’s intended to define an implicit conversion, or the author simply forgot to mark it.</li>
<li>It’s not always clear which type should provide the conversion, and if they both do, the code becomes ambiguous.</li>
<li>List initialization ca suffer form the same problems if the destination type is implicit, particularly if the list has only a single element.</li>
</ul>
</dd>
<dt>Decision:</dt>
<dd><p class="first">Type conversion operators, and constructors that are callable with a single argument, must be marked <code class="docutils literal"><span class="pre">explicit</span></code> in the class definition.  As an exception, copy and move constructors should not be <code class="docutils literal"><span class="pre">explicit</span></code>, since they do not preform type conversion. Implicit conversion can sometimes be necessary and appropriate for types that are designed to transparently wrap other types. In that case, contact you project leads to request a waiver of this rule.</p>
<p class="last">Constructors that cannot be called with a single argument should usually omit <code class="docutils literal"><span class="pre">explicit</span></code>. Constructors that take a single <code class="docutils literal"><span class="pre">std::initializer_list</span></code> parameter should also omit <code class="docutils literal"><span class="pre">explicit</span></code>, in order to support copy-initialization (e.g. <code class="docutils literal"><span class="pre">MyType</span> <span class="pre">m</span> <span class="pre">=</span> <span class="pre">{1,</span> <span class="pre">2};</span></code>)</p>
</dd>
</dl>
</div>
<div class="section" id="copyable-and-movable-types">
<h2>Copyable and Movable Types<a class="headerlink" href="#copyable-and-movable-types" title="Permalink to this headline">¶</a></h2>
<p>Support copying and/or moving if these operattions are clear and meaningful for your type. Otherwise, disable the implicityly generated special funcitons that preform copies and moves.</p>
<dl class="docutils">
<dt>Definition:</dt>
<dd><p class="first">A copyable type allows its objects to be initialized or assigned from any other object of the same type, the copy behavior is defined by the copy constructor and the copy-assignment operator. <code class="docutils literal"><span class="pre">string</span></code> is an example of a copyable type.</p>
<p>A movable type is one that can be initialized and assigned from temporaries (all copyable types are therefor movable). <code class="docutils literal"><span class="pre">std::unique_ptr&lt;int&gt;</span></code> is an example of a movable but not copyable type. For user-defined types, the move behavior is defined by the move constructor and the move-assignment operator.</p>
<p class="last">THe copy/move constructors can be implicity invoked by the computer in soem situations, d.g. when passing object by value.</p>
</dd>
<dt>Pros:</dt>
<dd><p class="first">Objects of copyable and movable types can be passed and returned by value, which makes APIs simpler, safer, and more general. Unlike when passing objects by pointer or reference, there’s no risk of confusin or ownership, lifetime, mutability, and similar issues, and no need to specify them in the contract. It also prevents non-local interactions between the client and the implementation, which makes them easier to understand, maintain, and optimize by the compiler. FUrther, such objects can be used with generic APIs additional flexibility in e.g., type composition.</p>
<p>Copy/move constructors and assignment operators are usually easier to define correctly than alternitives like <code class="docutils literal"><span class="pre">Clone()</span></code>, <code class="docutils literal"><span class="pre">CopyFrom()</span></code>, or <code class="docutils literal"><span class="pre">Swap()</span></code>, because they can be generated by the compiler, either implicity or with <code class="docutils literal"><span class="pre">=</span> <span class="pre">default</span></code>. They are concise, and ensure that all data members are copied. Copy and move constructors are also generally more efficent, because they don’t require heap allocation or seperate initialization and assignment steps, and they’re eligible for optimizations such as <a href="#id3"><span class="problematic" id="id4">`Copy Elison`_</span></a>.</p>
<p class="last">Move operators alow the implicit and efficient transfer of resources out of rvalue objects. this allows a plainer coding style in some cases.</p>
</dd>
<dt>Cons:</dt>
<dd><p class="first">Some types do not need to be copyable, and providing copy operators for such types can be confusing, nonsensical, or outright incorrect. Types representing singleton objects (<code class="docutils literal"><span class="pre">Registerer</span></code>), objects tied to specific scope (<code class="docutils literal"><span class="pre">Cleanup</span></code>), or closely coupled to object identity (<code class="docutils literal"><span class="pre">Mutex</span></code>) cannot be copied meaningfully. COpy opeations for base class types that are to be used poymorphically are hazardous, because use of them can lead to <a href="#id5"><span class="problematic" id="id6">`Object Slicing`_</span></a>. Defaulted or carelessly-implemented copy operations can be incorrect, and the resulting bugs can be confusing and difficult to diagnose.</p>
<p class="last">COpy constructros are invoked implicity, which makes the invocation easy to miss. THis may cause confusion for programmers used to languages where pass-by-referce is conventional or mandatory. It may also encourage excessive copying, which can cuase preformeance problems.</p>
</dd>
<dt>Decision:</dt>
<dd><p class="first">Provide the copy and move operations if their meaning is clear to a casual user and the copy/moving does not incur unexpected costs. If you define a copy or move constructor, define the corresponding assignment operator, and vice-versa.If your type is copyable, do not define move operations unless they are significantly more efficient thatn the corresponding copy operations. If your type is not copyable, but the conrrectness of a move is obvious to users of the type, you may make the type move-only by defining both of the move operations.</p>
<p class="last">If your type provides copy operations, it is recommended that you design your class so that the default implementation of those operations is correct. Remember to review the correctness of any defaulted operations as you would any other code, and to document that your class is copyable and/or cheaply movable if that’s and API guarantee.</p>
</dd>
</dl>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
 <span class="k">public</span><span class="o">:</span>
  <span class="n">Foo</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">field_</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">field</span><span class="p">)</span> <span class="p">{}</span>
  <span class="c1">// Bad, defines only move constructor, but not operator=.</span>

 <span class="k">private</span><span class="o">:</span>
  <span class="n">Field</span> <span class="n">field_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Due to the risk of slicing, avoid providing an assignment operator or public copy/move constructor for a class that’s intended to be derived from (and avoid deriving form a class with such members). If your base class needs to be copyable, provide a public virtual <code class="docutils literal"><span class="pre">Clone()</span></code> method, and a protected copy constructor that derived classes can use to implement it.</p>
<p>If you do not want to support copy/move operations on your type, explicity disable them using <code class="docutils literal"><span class="pre">=</span> <span class="pre">delete</span></code> in the <code class="docutils literal"><span class="pre">public:</span></code> section:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// MyClass is neither copyable nor movable.</span>
<span class="n">MyClass</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="n">MyClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="structs-vs-classes">
<h2>Structs vs. Classes<a class="headerlink" href="#structs-vs-classes" title="Permalink to this headline">¶</a></h2>
<p>Use a <code class="docutils literal"><span class="pre">struct</span></code> only for passive objects that carry data; everything else is a <code class="docutils literal"><span class="pre">class</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">struct</span></code> and <code class="docutils literal"><span class="pre">class</span></code> keywords behave almost identically in C++. We add our own semantic meanings to each keyword, so you should use the appropriate keyword for the data-type your defining.</p>
<p><code class="docutils literal"><span class="pre">struct</span></code>s should be used for passive objects that carry data, and may have associated constants, but lack any funcionality other than access/setting the data members. The access/setting of fields is done by directly accessing the fields rather than through method invocations. Methods should not provide behavior by should only be used to set up the data members e.g., <code class="docutils literal"><span class="pre">constructor</span></code>, <code class="docutils literal"><span class="pre">destructor</span></code>, <code class="docutils literal"><span class="pre">Initialize()</span></code>, <code class="docutils literal"><span class="pre">Reset()</span></code>, <code class="docutils literal"><span class="pre">Validate()</span></code>.</p>
<p>If more functionality is required, a <code class="docutils literal"><span class="pre">class</span></code> is more appropriate. If in doubt, make it a <code class="docutils literal"><span class="pre">class</span></code>.</p>
<p>Conf consistency with Stl you can use <code class="docutils literal"><span class="pre">struct</span></code> instead of <code class="docutils literal"><span class="pre">class</span></code> for functor and traits.</p>
<p>Note that member variables in structs and classes have <a href="#id7"><span class="problematic" id="id8">`Different Naming Rules`_</span></a>.</p>
</div>
<div class="section" id="inheritance">
<h2>Inheritance<a class="headerlink" href="#inheritance" title="Permalink to this headline">¶</a></h2>
<p>Composition is often more appropriate than inheritance. When using inheritance, make it <code class="docutils literal"><span class="pre">public</span></code>.</p>
<dl class="docutils">
<dt>Definition:</dt>
<dd>When a sub-class inherits form a base class, it includes the definitions of all the data and operations that the parent base class defines. In practice, inheritance is used in two major ways in C++: implementation inheritance, in which actual code is inherited by the child, and <a href="#id9"><span class="problematic" id="id10">`Interface Inheritance`_</span></a>, in which only method names are inherited.</dd>
<dt>Pros:</dt>
<dd>Implementation inheritace reduces code size by re-using the base class code as it specializes an existing type. Because inheritance is a compile-time declaration, you and the compiler can understand the operation and detect errors. Interface inheritance can be used to programmatically enforce that a class expose a particular API. Again th ecompiler can detect errors, in this  case, when a class does not define a necessary method of the API.</dd>
<dt>Cons:</dt>
<dd>For implementation inheritance, because the code implementing a sub-class is spread between the base and the sub-class, it can be more difficult to understand an implementation. The sub-class cannot override functions that are not virtual, so the sub-class cannot change implementation. The base class may also define some data members, so that specifies phyical layout of the base class.</dd>
<dt>Decision:</dt>
<dd><p class="first">All inheritance should be <code class="docutils literal"><span class="pre">public</span></code>. If you want to do <code class="docutils literal"><span class="pre">private</span></code> inheritance, you should be including an instance of the base class as a member instead.</p>
<p>Do not overuse implementation inheritance. Composition is often more appropriate. Try to restrict usse of inheritance to the “is-a” case: <code class="docutils literal"><span class="pre">Bar</span></code> subclasses <code class="docutils literal"><span class="pre">Foo</span></code> if it can reasonably be said that <code class="docutils literal"><span class="pre">Bar</span></code> “is a kind of” <code class="docutils literal"><span class="pre">Foo</span></code>.</p>
<p>Make your destructor <code class="docutils literal"><span class="pre">virtual</span></code> if necessary. If your class has <code class="docutils literal"><span class="pre">virtual</span></code> methods, itd destructor should be <code class="docutils literal"><span class="pre">virtual</span></code>.</p>
<p>Limit the use of <code class="docutils literal"><span class="pre">protected</span></code> to those member functions that might need to be accessed from subclasses. Not that <a href="#id11"><span class="problematic" id="id12">`Data Members Should Be Private`_</span></a>.</p>
<p class="last">Explicitly annotate overrides of virtual functions or virtual destructors with an override or (less frequently) final specifier. Older (pre-C++11) code will ue the <code class="docutils literal"><span class="pre">virtual</span></code> keyword as an inferior alternative annotation. For clarity, use exactly one of <code class="docutils literal"><span class="pre">override</span></code>, <code class="docutils literal"><span class="pre">final</span></code>, or <code class="docutils literal"><span class="pre">virtual</span></code> when declaring an override. Rational: A function or destructor marked override or final that isnot an override of a base class virtual function will not compile, and this helps catch common errors. THe specifiers serve as documentation; if no specifier is present, the reader has to check all ancestors of the class in question to tdetermin if the function or destructor is virtual or not.</p>
</dd>
</dl>
</div>
<div class="section" id="multiple-inheritance">
<h2>Multiple Inheritance<a class="headerlink" href="#multiple-inheritance" title="Permalink to this headline">¶</a></h2>
<p>Only very rarely is multiple implementation inheritance actually useful. We allow multiple inheritance only when at most one of the base classes has an implementation; all other base classes must be <a href="#id13"><span class="problematic" id="id14">`Pure Interface`_</span></a> classes tagged with the <code class="docutils literal"><span class="pre">Interface</span></code> suffix.</p>
<dl class="docutils">
<dt>Definition:</dt>
<dd>Multiple inheritance allows a sub-class to have more than one base class. We distinguish between base classes that are <em>pure interfaces</em> and those that have <em>implementation</em>.</dd>
<dt>Pros:</dt>
<dd>Multiple implementation inheritance may let you re-use even more code than single inheritance (see <a class="reference internal" href="#inheritance">Inheritance</a>).</dd>
<dt>Cons:</dt>
<dd>Only very rarely is multiple <em>implementation</em> inheritance actually useful. When multiple implementation inheritance seems like the solution, you can usually find a different, more explicit, and cleaner solution.</dd>
<dt>Decision:</dt>
<dd>Muliple inheritance is allowed only when all superclasses, with the possible exception of the first one, are <a href="#id15"><span class="problematic" id="id16">`Pure Interfaces`_</span></a>. In order to ensure that they remain pure interfaces, they must end with the <code class="docutils literal"><span class="pre">Interface</span></code> suffix.</dd>
</dl>
</div>
<div class="section" id="interfaces">
<h2>Interfaces<a class="headerlink" href="#interfaces" title="Permalink to this headline">¶</a></h2>
<p>Classes taht satisfy certain conditions are allowed, but not required, to end with the <code class="docutils literal"><span class="pre">Interface</span></code> suffix.</p>
<dl class="docutils">
<dt>Definition:</dt>
<dd><p class="first">A class is a pure interface if it meets the following requirements:</p>
<ul class="simple">
<li>It has only public pure virtual (“= 0”) methods and static methods (but see below for destructor).</li>
<li>It may not have non-static data members.</li>
<li>It needs not have any constructors defined. If a constructor is provided, it must take no arguments and must be protected.</li>
<li>If it is a subclass, it may only be derived from classes that satisfy these conditions and are tagged with the <code class="docutils literal"><span class="pre">Interface</span></code> suffix.</li>
</ul>
<p class="last">An interface class can never be directly instantiated because of the pure virtual method(s) it declares. To make sure all implementations of the interface can be destroyed correctly, the interface must also declare a virtual destructor (in an exception to the first rule, this dhouls not be pure).</p>
</dd>
<dt>Pros:</dt>
<dd>Tagging a class with the <code class="docutils literal"><span class="pre">Interface</span></code> suffix lets other know that they must not add implemented methods or non static data members. This is particularly important in the case of <a class="reference internal" href="#multiple-inheritance">Multiple Inheritance</a>. Additionally, the interface concept is already well-understood by Java programmers.</dd>
<dt>Cons:</dt>
<dd>The <code class="docutils literal"><span class="pre">Interface</span></code> suffix lengthens the class name, which can make it harder to read and understand. Also, ther interface property may be considered an implementation detail that shouldn’t be exposed to clients.</dd>
<dt>Decision:</dt>
<dd>A class may end with <code class="docutils literal"><span class="pre">Interface</span></code> only if it meets that aboce requierments. We do not require the converse, however: classes that meet the above requirements are not required to end with <code class="docutils literal"><span class="pre">Interface</span></code>.</dd>
</dl>
</div>
<div class="section" id="operator-overloading">
<h2>Operator Overloading<a class="headerlink" href="#operator-overloading" title="Permalink to this headline">¶</a></h2>
<p>Overload operators judiciously. Do not create user-defined literals.</p>
<dl class="docutils">
<dt>Definition:</dt>
<dd><a href="#id1"><span class="problematic" id="id2">C__</span></a> permits user code to <a href="#id17"><span class="problematic" id="id18">`Declare Overloaded Versions of the Build-in Operators`_</span></a> using the <code class="docutils literal"><span class="pre">operator</span></code> keyword, so long as one of the parameters is a user-defined type. the <code class="docutils literal"><span class="pre">operator</span></code> keyword also permits user code to define new kinds of literals using <code class="docutils literal"><span class="pre">operator&quot;</span> <span class="pre">&quot;</span></code>, and to define type-conversion funcitons such as <code class="docutils literal"><span class="pre">operator</span> <span class="pre">bool()</span></code>.</dd>
<dt>Pros:</dt>
<dd><p class="first">Operator overloading can make code more concise and intuitaive by enabling user-defined types to behave the same as built-in types. Overloading operators are the idiomatic names for certain operations (e.g. <code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">&lt;</span></code> , <code class="docutils literal"><span class="pre">=</span></code>, and <code class="docutils literal"><span class="pre">&lt;&lt;</span></code>), and adhering to those conventions can make user-defined types more readable and enable them to interoperate with libraries that expect those names.</p>
<p class="last">User-defined literals are a vary concise notation for creating objects of user-defined types.</p>
</dd>
<dt>Cons:</dt>
<dd><ul class="first last simple">
<li>Providing a correct, consistent, and unsurprising set of operator overloads requires some care, and failure to do so can lead to confusion and bugs.</li>
<li>Overuse of operators can lead to obfuscated code, particularly if the overloaded operator’s semantics don’t follow convention.</li>
<li>The hazards of function overloading apply just as mutch to operator overloading, if not more so.</li>
<li>Operator overloads can fool our intuition into thinking that expensive operations are cheap, built-in operations.</li>
<li>Finding the call sites for overloaded operators may require a search tool that’s aware of C++ syntacx, reather than e.g. grep.</li>
<li>If you get the argument type of an overloaded operator wrong, you may get a different overload rather than a compiler error. For ecample, <code class="docutils literal"><span class="pre">foo</span> <span class="pre">&lt;</span> <span class="pre">bar</span></code> may do one thing, while <code class="docutils literal"><span class="pre">&amp;foo</span> <span class="pre">&lt;</span> <span class="pre">&amp;bar</span></code> does something totally different.</li>
<li>Certain operator overloads are inherently hazardous. Overloading unary &amp; can cause the same code to have different meanings depending on whether the overload declaration is visible. Overloads of <code class="docutils literal"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal"><span class="pre">||</span></code>, and <code class="docutils literal"><span class="pre">,</span></code> cannot match the evaluation-order semantics of the built-in operators.</li>
<li>Operators are often defined outside the class, so there’s a risk of different files introducing different definitions of the same operator. If both definitions are linked inot the same binary, this result is undefined behavior, which can manifest as subtle run-time bugs.</li>
<li>User-defined literals allow the creation of new syntactic forms that are unfamiliar even to experienced C++ programmers.</li>
</ul>
</dd>
<dt>Decision:</dt>
<dd><p class="first">Define overloaded operators only if their meaning is obvious, unsurprising, nad consistent with the corresponding built-in operators. For example, use <code class="docutils literal"><span class="pre">|</span></code> as a bitwise- or logical-or, not as a shell-style pipe.</p>
<p>Define operators only on your own types. More precisely define them in the same headers, <code class="docutils literal"><span class="pre">.cpp</span></code> files, and namespaces as the types they operate on. That way, the operators are available wherever the type is, minimizing the risk of multiple definitions. If possible, avoid defining operators as templates, because they must satisfy this rule for any possible template arguments. If you define an operator, also define any related operators that make sense, and make sure they are defined consistently. For example, if you overload <code class="docutils literal"><span class="pre">&lt;</span></code>, overload all the comparison operators, and make sure <code class="docutils literal"><span class="pre">&lt;</span></code> and <code class="docutils literal"><span class="pre">&gt;</span></code> never return <code class="docutils literal"><span class="pre">true</span></code> for the same arguments.</p>
<p>Prefer to define non-modifying binary operators as non-member functions. If a binary operator is defined as a class member, implicit conversions will apply to the right-hand argument, but not the left one. It wil confuse your users if <code class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></code> compiels bu <code class="docutils literal"><span class="pre">b</span> <span class="pre">&lt;</span> <span class="pre">a</span></code> doesn’t.</p>
<p>Don’t go out of your way to avoid defining operator overloads. For example, preer to define <code class="docutils literal"><span class="pre">==</span></code>, <code class="docutils literal"><span class="pre">=</span></code>, and <code class="docutils literal"><span class="pre">&lt;&lt;</span></code>, rather than <code class="docutils literal"><span class="pre">Equals()</span></code>, <code class="docutils literal"><span class="pre">CopyFrom()</span></code>, and <code class="docutils literal"><span class="pre">PrintTo()</span></code>. Conversely, don’t define operator overloads just because other libraries expect them. FOr example, if your type doensn’t have a natural ordering, but you want to store it in a <code class="docutils literal"><span class="pre">std::set</span></code>, use a custom comparator rather than overloading <code class="docutils literal"><span class="pre">&lt;</span></code>.</p>
<p>Do not overload <code class="docutils literal"><span class="pre">&amp;&amp;</span></code>, <code class="docutils literal"><span class="pre">||</span></code>, <code class="docutils literal"><span class="pre">,</span></code>, or unary <code class="docutils literal"><span class="pre">&amp;</span></code>. Do not overload <code class="docutils literal"><span class="pre">operator&quot;</span> <span class="pre">&quot;</span></code>, i.e. do not introduce user-defined literals.</p>
<p class="last">Type conversion operators are covered in the section on <a class="reference internal" href="#implicit-conversions">Implicit Conversions</a>. The <code class="docutils literal"><span class="pre">=</span></code> operator is covered in the section on <a href="#id19"><span class="problematic" id="id20">`Copy Constructors`_</span></a>. Overloading <code class="docutils literal"><span class="pre">&lt;&lt;</span></code> for use with streams is convered in the section on <a href="#id21"><span class="problematic" id="id22">`Streams`_</span></a>. See also the rules on <a href="#id23"><span class="problematic" id="id24">`Function Overloading`_</span></a>, which apply to operator overloading as well.</p>
</dd>
</dl>
</div>
<div class="section" id="access-control">
<h2>Access Control<a class="headerlink" href="#access-control" title="Permalink to this headline">¶</a></h2>
<p>Make data members <code class="docutils literal"><span class="pre">private</span></code> unless they are <code class="docutils literal"><span class="pre">static</span> <span class="pre">const</span></code> (and follow the <a href="#id25"><span class="problematic" id="id26">`Naming Convention for Constants`_</span></a>). FOr technical reasons, we allow data members of a test fixture class to be <code class="docutils literal"><span class="pre">protected</span></code> when using <a href="#id27"><span class="problematic" id="id28">`Google Test`_</span></a>.</p>
</div>
<div class="section" id="declaration-order">
<h2>Declaration Order<a class="headerlink" href="#declaration-order" title="Permalink to this headline">¶</a></h2>
<p>Group similar declarations together, placing public parts earlier.</p>
<p>A class definition should usually start with a <code class="docutils literal"><span class="pre">public:</span></code> section, followed by <code class="docutils literal"><span class="pre">protected:</span></code>, then <code class="docutils literal"><span class="pre">private:</span></code>. Omit sections that would be empty.</p>
<p>Within each section, generally prefer grouping similar kinds of declarations together, and generally prefer the following order: types (including <code class="docutils literal"><span class="pre">typedef</span></code>, <code class="docutils literal"><span class="pre">using</span></code>, and nested structs and classes), constants, factory functions, constructors, assignment operators, destructor, all other methods, data members.</p>
<p>Do not put large method definitions inline in the class definition. Usually, only trivial or preformance-critical, and very short, methods may be defined inline. See <a href="#id29"><span class="problematic" id="id30">`Inline Functions`_</span></a> for more details.</p>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="functions.html" class="btn btn-neutral float-right" title="Functions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="scoping.html" class="btn btn-neutral" title="Scoping" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017 Arden Rasmussen.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>